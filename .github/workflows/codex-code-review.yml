name: Codex Code Review

concurrency:
  group: codex-code-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

on:
  pull_request:
    types: [opened, synchronize, ready_for_review, reopened]

jobs:
  codex:
    runs-on: ubuntu-latest

    permissions:
      contents: read

    outputs:
      final_message: ${{ steps.run_codex.outputs.final-message }}

    steps:
      - uses: actions/checkout@v5
        with:
          # Explicitly check out the PR's merge commit.
          ref: refs/pull/${{ github.event.pull_request.number }}/merge

      - name: Pre-fetch base and head refs for the PR
        run: |
          git fetch --no-tags origin \
            ${{ github.event.pull_request.base.ref }} \
            +refs/pull/${{ github.event.pull_request.number }}/head

      # If you want Codex to build and run code, install any dependencies that
      # need to be downloaded before the "Run Codex" step because Codex's
      # default sandbox disables network access.

      - name: Run Codex
        id: run_codex
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          # TODO: Extract to a file using "prompt-file".
          prompt: |
            This is PR #${{ github.event.pull_request.number }} for ${{ github.repository }}.

            Review ONLY the changes introduced by the PR, so consider:
               git log --oneline ${{ github.event.pull_request.base.sha }}...${{ github.event.pull_request.head.sha }}

            Load and use the following agent skills that are available in the `./.agents/skills` folder to suggest improvements, potential bugs, or issues,
            but do not limit yourself to the skills.

            Run the following agent skills on every `.ts`, `.tsx`, `.js`, `.jsx` file (changed lines only):
                - `/accessibility`
                - `/best-practices`
                - `/core-web-vitals`
                - `/performance`
                - `/web-quality-audit`

            Run the following agent skills on files based on their imports (changed lines only):

                - Files importing `@squide/*` -> `/workleap-squide`
                - Files importing `@workleap/logging` -> `/workleap-logging`
                - Files importing `@workleap/telemetry` -> `/workleap-telemetry`
                - Files importing `@workleap/browserslist-config`, `@workleap/eslint-configs`, `@workleap/stylelint-plugin`, `@workleap/typescript-configs`, `@workleap/rsbuild-configs`, `@workleap/rslib-configs` -> `/workleap-web-configs`

            Run the following agent skills on files matching by name or file type:

                - `turbo.json` -> `/turborepo`

            Be concise and specific in your feedback.

            When reporting issues:

                - If the issue matches an agent skill or a custom guideline, name it explicitly.
                - Otherwise, choose an appropriate category based on the nature of the issue.
                - Always include the exact code location (`file:line` or line range).
                - Output must be valid JSON that conforms to `.github/codex/schemas/pr-review.schema.json`.
                - Return only JSON, no markdown or extra commentary.
                - The JSON must be shaped as:
                  {
                    "summary": "string",
                    "comments": [
                      { "path": "path/to/file", "line": 123, "side": "RIGHT", "body": "comment text", "category": "accessibility" }
                    ]
                  }
                - `category` is required by the schema. Use a skill name when applicable, otherwise a non-skill category.
                - Allowed categories: "" (only if truly uncategorized), accessibility, best-practices, core-web-vitals, performance, web-quality-audit, turborepo, workleap-logging, workleap-squide, workleap-telemetry, workleap-web-configs, bug, best-practice, security, reliability, maintainability, testing, docs, style, compatibility.
                - `side` is required. Use `RIGHT` for PR changes unless you are explicitly referencing the base.

            Pull request title and body:
            ----
            ${{ github.event.pull_request.title }}
            ${{ github.event.pull_request.body }}
          codex-args: >
            ["--output-schema", ".github/codex/schemas/pr-review.schema.json"]

  post_feedback:
    runs-on: ubuntu-latest
    needs: codex

    permissions:
      issues: write
      pull-requests: write

    if: needs.codex.outputs.final_message != ''

    steps:
      - name: Report Codex feedback
        uses: actions/github-script@v7
        env:
          CODEX_FINAL_MESSAGE: ${{ needs.codex.outputs.final_message }}
        with:
          github-token: ${{ github.token }}
          script: |
            let payload;
            try {
              payload = JSON.parse(process.env.CODEX_FINAL_MESSAGE);
            } catch (error) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `Codex output format error: ${error.message}`
              });
              return;
            }

            const comments = Array.isArray(payload.comments) ? payload.comments : [];

            const agentTag = "Agent: codex";
            const prNumber = context.payload.pull_request.number;

            if (comments.length === 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: [payload.summary || "No issues found.", agentTag].join("\n\n")
              });
              return;
            }

            const listAllFiles = async () => {
              const files = [];
              let page = 1;
              while (true) {
                const response = await github.rest.pulls.listFiles({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  per_page: 100,
                  page
                });
                files.push(...response.data);
                if (response.data.length < 100) {
                  break;
                }
                page += 1;
              }
              return files;
            };

            const buildPositionMap = (files) => {
              const map = new Map();

              for (const file of files) {
                if (!file.patch) {
                  continue;
                }

                const positions = new Map();
                const lines = file.patch.split("\n");
                let newLine = null;
                let position = 0;

                for (const line of lines) {
                  position += 1;

                  if (line.startsWith("@@")) {
                    const match = line.match(/\+(\d+)(?:,(\d+))?/);
                    if (match) {
                      newLine = Number(match[1]);
                    } else {
                      newLine = null;
                    }
                    continue;
                  }

                  if (newLine === null) {
                    continue;
                  }

                  if (line.startsWith("+") && !line.startsWith("+++")) {
                    positions.set(newLine, position);
                    newLine += 1;
                    continue;
                  }

                  if (line.startsWith("-") && !line.startsWith("---")) {
                    continue;
                  }

                  newLine += 1;
                }

                if (positions.size > 0) {
                  map.set(file.filename, positions);
                }
              }

              return map;
            };

            const files = await listAllFiles();
            const positionMap = buildPositionMap(files);

            const mappedComments = comments.map(c => {
              const line = Number(c.line);
              const filePositions = positionMap.get(c.path);
              const position = filePositions ? filePositions.get(line) : undefined;
              return { ...c, position };
            });

            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                event: "COMMENT",
                body: [payload.summary, agentTag].filter(Boolean).join("\n\n"),
                comments: mappedComments.map(c => ({
                  path: c.path,
                  position: c.position,
                  body: [
                    c.body,
                    c.category ? `Category: ${c.category}` : "",
                    agentTag
                  ].filter(Boolean).join("\n\n")
                }))
              });
            } catch (error) {
              const fallbackBody = [
                payload.summary || "Codex review findings",
                "Inline review failed; posting summary list instead.",
                agentTag,
                ...comments.map(c => `${c.path}:${c.line} - ${c.body}`)
              ].filter(Boolean).join("\n\n");

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: fallbackBody
              });
            }
